
简单排序    O(n^2)      O(n^2)      O(1)

快速排序    O(nlogn)    O(n^2)      O(n)

堆排序      O(nlogn)    O(nlogn)    O(1)

归并排序    O(nlogn)    O(nlogn)    O(n)    稳定

计数排序    O(n)        O(k)        O(n)    稳定
关键字的值key满足0<key<k

链式基数排序    O(dn)       O(dn)       O(k)    稳定
d为关键字个数，n为记录数，k为关键字可能取值的最大数目

排序过程的判定树必须含有n!个叶子结点，一个比较排序算法的最坏情况比较次数与判定树树高相等。设树高为h，则n! <= 2^h，即h >= lg(n!) = Omege(nlgn)。因此，基于比较操作的排序算法最坏情况下能达到的最好时间复杂度为Omega(nlogn)（最坏情况下界，即树高至少为nlgn）；


对顺序表进行排序时可以作地址排序，以减少元素的移动次数，最后再作一次重排；
    void Rearange( SqList &L, int adr[])
    {
        // adr为顺序表L的有序次序，第i个元素应该是L.r[adr[i] ]
        for ( i = 1; i<L.Length; ++i )
        {
            if (adr[i]!=i ) {
                j = i; L.r[0] = L.r[i]; // 暂存记录

                while (adr[j]!= i ) {

                    // L.r[j] = L.r[adr[j]]
                    // 第j个元素应该是L.r[adr[j]]
                    k = adr[j]; L.r[j] = L.r[k];
                    adr[j] = j; j = k;
                }

                // 此时adr[j] == i
                L.r[j] = L.r[0]; adr[j] = j; 
            }
        }
    }



1.借助插入操作的排序

插入排序：
// 对顺序表L作直接插入排序  
void InsertSort (SqList &L ) {
    for (i=2; i<=L.length; ++i )
        if ( LT(L.r[i].key, L.r[i-1].key ) ) {
            // 当前元素比前一元素小，寻找插入位置
            L.r[0] = L.r[i]; // 复制哨兵数，注意哨兵数的作用
            L.r[i] = L.r[i-1]; // 移动第一个元素 

            for( j=i-2; LT( L.r[0].key, L.r[j].key); --j )
                L.r[j+1] = L.r[j]; // 记录后移

            // 把元素插入到正确位置
            L.r[j+1] = L.r[0];
        }
}

插入排序在顺序表有序的情况下比较次数为n-1，并且不需要移动元素；当顺序表逆序时，比较次数为(n+2)(n-1)/2 (2+3+...+n)，记录移动为(n+4)(n-1)/2 (3+4+...+ (n+1))，平均比较次数与移动记录次数约为 n^2 / 4


对直接插入排序的改进从两方面进行：减少比较次数，减少移动元素次数

折半插入排序：定位元素的插入位置时使用折半查找（减少比较次数）
    ...
    while( low <= high ) {
        m = (low+high) /2 ;
        if( LT(L.r[0].key, L.r[m].key) ) high = m-1;
        else low = m+1;
    }
    // 插入点为high+1


2-路插入排序：在折半插入排序的基础上改进（减少移动次数）
    
    49 () () () () () () () () () 
       ^                       ^
           |                       |
         final                   first
    
    从第二个元素开始，比49大的元素在49与final索引之间查找插入位置（折半查找），比49小的元素在first索引与49之间查找插入位置（减少了一个的位置移动）


    49 65 76 () () () () () 13 27
         ^           ^
         |           |
           final        first

表插入排序：使用静态链表作存储结构（不需要元素移动，修改2n次指针）

            0       1   2   3   4  5
    +----------------------------+
        |MAXINT   | 49| 38| 65| 97|13|
        |  2      | 3 |  1|  0|  -| -|
        +----------------------------+
        修改指针相当于链表的插入，可以根据链表指针对记录进行重排，以允许随机查找

Shell's sort：Dimininishing Increment Sort
待排记录序列基本有序时，直接插入排序效率较高
    
        void ShellSort( SqList &L, int dlta[], int t )
    { 
        // 按增量序列dlta[0...t-1]对顺序表L作Shell's sort
        // 即作插入排序时元素间隔为dlta[k]
        for (k=0; k<t; ++k )
            ShellInsert(L, dlta[k]);
    }


2.借助交换操作的排序
冒泡排序：
    对数组的第一趟操作把最大数交换到最后一个位置n，第二趟操作把第二大数交换到n-1位置，以此类推

快速排序（分治法经典）：
    把pivot元素交换到最终排序序列的正确位置上

    快速排序的一趟操作：
    patition(SqList &L, int low, int high) {
        L.r[0] = L.r[low];  // pivot元素放置在0位置
        pivotkey = L.r[low].key;

        // 最后low == high
        while (low < high )
        {
            //比pivot小的元素移到前面
            while (low<high && L.r[high].key >= pivotkey )
                --high;
            L.r[low] = L.r[high] 

            //比pivot大的元素移到数组后边
            while (low<high && L.r[low].key <= pivotkey)
                ++low;
            L.r[high] = L.r[low]
        }
        L.r[low] = L.r[0]
        return low; // 返回划分索引位置
    }

T(n) = n + T(k-1) + T(n-k)，当序列有序时，快速排序退化为冒泡排序；改进：在指针high减1和low增1的同时进行“起泡”操作，若在一趟划分中没有“起泡”（交换）操作，则序列已有序；


3.选择排序
简单选择排序：
    void SelectSort( SqList &L )
    {
        // 选择第i小的记录，交换到位
        for (i=1; i<L.length; ++i )
        {
            // 从L.r[i...L.length]中选择最小的记录
            j = SelectMinKey(L, i ); 
            if (i!=j) L.r[i] <--> L.r[j]; //交换
        }
    }

选择排序在n个关键字中选出最小值时进行n-1次，能不能在接下来的选择第2小的关键字时，不进行n-2次操作呢？当然可以；

树形选择（胜者树）：
                          13
                       /      \
                   38            13
                 /    \         /    \
              38       65      13      27
             /  \     /  \    /  \    /   \
          49    38   65  97  76   13  27  49

    输出13后以MAXINT代替13，修改叶子到根的路径上的关键字，选出次小关键字
    （辅助空间多，需要与MAXINT的比较）


堆排序：
                        13
                       /   \
                    38       27
                   /  \     /   \
                49     76  65    49
               /
             97
                 小顶堆（完全二叉树）
        输出13后，用97代替，从根结点向下调整堆结构；
        
        建堆时从最后一个非终端结点开始（floor(length/2)）
        void HeapSort( HeapType &H )
        {
            // 建成大顶堆
            for( i = H.length/2; i>0; --i )    // H[1 ... length]为数据
                HeapAdjust( H, i, H.length );

            for( i = H.length; i>1; --i )
            {
                H.r[1] <--> H.r[i]; // 输出堆顶元素

                // 调整堆
                HeapAdjust( H, 1, i-1);
            }
        }       

堆排序的运行时间主要耗费在建堆与调整新堆时的“筛选”操作上，深度为k的堆，筛选算法中的关键字比较至多为2(k-1)；



归并排序（2路归并）：
    void MSort( RcdType SR[], RcdType &TR1[], int s, int t ) {
        //将SR[s..t]归并排序为TR1[s..t]
        if (s==t ) TR1[s] = SR[s];
        else {
            m = (s+t) / 2;

            // 将SR[s..m]归并为有序的TR2[s..m]
            MSort (SR, TR2, s, m);

            // 将SR[m+1..t]归并为有序的TR2[m+1..t]
            MSort (SR, TR2, m+1, t);

            // 合并TR2[s..m]，TR2[m+1..t]到TR1[s..t]中
            Merge (TR2, TR1, s, m, t );
        }
    }

    2路归并算法不常用，多用多路归并；


4.计数排序，桶排序
若待排元素满足第个元素都是介于0到k之间的整数且k=O(n)，可以考虑使用计数排序;
    void countSort( A, B, k)
    {
        //对数组A进行排序放入数组B中，k为数组大小

        // 初始化计数数组C
        for i <- 0 to k
            do C[i] <- 0

        // 统计元素出现次数
        for  j <- 1 to length[A]
            do C[A[j]] <- C[A[j]] + 1 

        // 统计小于或等于i的元素个数
        for i <- 1 to k
            do C[i] <- C[i] + C[i-1]

        // 元素A[j]的最终排序位置在C[ A[j] ]    
        for j <- length[A] downto 1
            do B[ C[ A[j] ] ] <- A[j]
               C[ A[j] ] <- C[ A[j] ] - 1
    }

桶排序：把区间[0,1)划分为n个相同大小的子区间（桶），将n个元素分布到桶中。输入数据均匀分布在[0, 1)中
    void bucketSort( A )
    {
        n <- length[A]
        
        // 把A中元素插入桶中
        for i <- 1 to n
            do inser A[i] into list B[ floor( n * A[i] ) ]

        for i <- 0 to n-1
            do sort list B[i] with insertion sort

        concatenate the lists B[0], B[1], ..., B[n-1] in order
    }

若A中元素分布为min < A[i] < max, 也可以令计算桶号的函数为floor( A[i] / (max - min + 1))，B数组元素个数为max-min+1






5.多关键字排序
基数排序：
    借助多关键字排序的思想对单逻辑关键字进行排序（如何对扑克牌排序？）

    ( K0, K1, K2 ), 0<= Ki <=9 且为整数，K0为最主关键字，如3位整数中的百位
    最高位优先法（MSD）：
        先按K0排序，将序列分割成若干子序列，对子序列分别排序后合并
    
    最低位优先法（LSD）：
        对整个序列先按K2排序，再对K1进行排序（必须是稳定的排序算法），再按K0进行排序（稳定排序）

    使用LSD方法时，可以使用“分配”与“收集”思想实现排序

    
    使用链式结构：
        ->278 -> 109 -> 063 -> 930 -> 589

        0: 930
        1: 
        ....
        9: 109 589

        ->930 ->063 -> 278 ->109 -> 589

    使用顺序结构：
        采用计数并“收集”的思想，类似于计数排序，需要n个记录与2*RADIX个计数单元的辅助空间
    



6.外部排序
    外部排序所需时间 = 内部排序（产生初始归并段）时间（m * tIS )  +
               外部读写时间（ d * tIO ) +
               内部归并所需时间 （s * u * tMG )

    m -> 初始归并段个数，tIS -> 一个归并段内部排序平均时间
    d -> 外存读写总次数，tIO -> 进行一次外存读/写平均时间
    s -> 归并的趟数，u * tMG -> 对u个记录进行内部归并的时间
    （tIO是主要的时间消耗，考虑如何能减少d，d又与s有关）

    如何有效减少外在信息读写次数呢？对m个初始归并段进行k路平衡归并时，归并的趟数为：s = floor( logk(m), k为底数)。因此增加k或减少m便能减少s，进而减少外存读写次数

多路平衡归并：
    降低归并树的深度

    使用多路归并使得归并树的深度降低，降低外存读写次数，但使得内部归并时间增加；
    对k路归并，得到u（k个归并段的总记录数）个记录的归并段需要进行(u-1)(k-1)次比较，因此内部归并过程中所用的比较次数为：
    floor(logk(m)) * (k-1) * (n-1)  

    使用败者树（双亲结点为败者，胜者往上参加另一场比赛），使得k个记录中选出最小关键字仅用floor( log2(k) )次比较
    floor(logk(m)) * floor(log2k) * (n-1)  = floor( log2m ) * (n-1)

    因此，总的内部归并时间保持不变；


置换-选择排序：
    减少初始归并段的数量，使用败者树（归并段长度并不相等）

最佳归并树：
    初始归并段的长度并不相等
    一棵（有可能加上虚段）的哈夫曼树（n个叶子节点的带权路径长度最短的二叉树），结点为归并段的记录数，路径长度为归并趟数，假设一个记录占用一个磁盘块

                2   3   6   
                  \ | /
                9  11  12  17 18 24
                  \ | /     \ | /
            30     32        59
               \    |      /
                   121
            加上0个虚段的3路最优归并树

    要是没有30这个段呢，直接在上边的树中去掉30并不是最优树（把6放到30的位置就比直接去掉30好），因此要附加长度为0的虚段，再构造哈夫曼树

    对k路归并而言，若(m-1) mod (k-1) = 0，则不需要加虚段（此时构造一棵哈夫曼树所有结点出度为0或k）；否则需要加 k - 1 - (m-1) mod (k-1) 个虚段（加上这个数量的虚段，(m' - 1) mod (k-1) = 0）； 
