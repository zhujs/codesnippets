
简单排序	O(n^2)		O(n^2)		O(1)

快速排序	O(nlogn)	O(n^2)		O(n)

堆排序		O(nlogn)	O(nlogn)	O(1)

归并排序	O(nlogn)	O(nlogn)	O(n)	稳定

计数排序	O(n)		O(k)		O(n)	稳定
关键字的值key满足0<key<k

链式基数排序	O(dn)		O(dn)		O(k)	稳定
d为关键字个数，n为记录数，k为关键字可能取值的最大数目

排序过程的判定树必须含有n!个叶子结点，一个比较排序算法的最坏情况比较次数与判定树树高相等。设树高为h，则n! <= 2^h，即h >= lg(n!) = Omege(nlgn)。因此，基于比较操作的排序算法最坏情况下能达到的最好时间复杂度为Omega(nlogn)（最坏情况下界，即树高至少为nlgn）；


对顺序表进行排序时可以作地址排序，以减少元素的移动次数，最后再作一次重排；
	void Rearange( SqList &L, int adr[])
	{
		// adr为顺序表L的有序次序，第i个元素应该是L.r[adr[i] ]
		for ( i = 1; i<L.Length; ++i )
		{
			if (adr[i]!=i ) {
				j = i; L.r[0] = L.r[i]; // 暂存记录

				while (adr[j]!= i ) {

					// L.r[j] = L.r[adr[j]]
					// 第j个元素应该是L.r[adr[j]]
					k = adr[j]; L.r[j] = L.r[k];
					adr[j] = j; j = k;
				}

				// 此时adr[j] == i
				L.r[j] = L.r[0]; adr[j] = j; 
			}
		}
	}



1.借助插入操作的排序

插入排序：
// 对顺序表L作直接插入排序	
void InsertSort (SqList &L ) {
	for (i=2; i<=L.length; ++i )
		if ( LT(L.r[i].key, L.r[i-1].key ) ) {
			// 当前元素比前一元素小，寻找插入位置
			L.r[0] = L.r[i]; // 复制哨兵数，注意哨兵数的作用
			L.r[i] = L.r[i-1]; // 移动第一个元素 

			for( j=i-2; LT( L.r[0].key, L.r[j].key); --j )
				L.r[j+1] = L.r[j]; // 记录后移

			// 把元素插入到正确位置
			L.r[j+1] = L.r[0];
		}
}

插入排序在顺序表有序的情况下比较次数为n-1，并且不需要移动元素；当顺序表逆序时，比较次数为(n+2)(n-1)/2 (2+3+...+n)，记录移动为(n+4)(n-1)/2 (3+4+...+ (n+1))，平均比较次数与移动记录次数约为 n^2 / 4


对直接插入排序的改进从两方面进行：减少比较次数，减少移动元素次数

折半插入排序：定位元素的插入位置时使用折半查找（减少比较次数）
	...
	while( low <= high ) {
		m = (low+high) /2 ;
		if( LT(L.r[0].key, L.r[m].key) ) high = m-1;
		else low = m+1;
	}
	// 插入点为high+1


2-路插入排序：在折半插入排序的基础上改进（减少移动次数）
	
	49 () () () () () () () () () 
	   ^                       ^
           |                       |
         final                   first
	
	从第二个元素开始，比49大的元素在49与final索引之间查找插入位置（折半查找），比49小的元素在first索引与49之间查找插入位置（减少了一个的位置移动）


	49 65 76 () () () () () 13 27
		 ^           ^
		 |           |
	       final        first

表插入排序：使用静态链表作存储结构（不需要元素移动，修改2n次指针）

            0       1   2   3   4  5
	+----------------------------+
        |MAXINT   | 49| 38| 65| 97|13|
        |  2      | 3 |  1|  0|  -| -|
        +----------------------------+
        修改指针相当于链表的插入，可以根据链表指针对记录进行重排，以允许随机查找

Shell's sort：Dimininishing Increment Sort
待排记录序列基本有序时，直接插入排序效率较高
	
        void ShellSort( SqList &L, int dlta[], int t )
	{ 
		// 按增量序列dlta[0...t-1]对顺序表L作Shell's sort
		// 即作插入排序时元素间隔为dlta[k]
		for (k=0; k<t; ++k )
			ShellInsert(L, dlta[k]);
	}


2.借助交换操作的排序
冒泡排序：
	对数组的第一趟操作把最大数交换到最后一个位置n，第二趟操作把第二大数交换到n-1位置，以此类推

快速排序（分治法经典）：
	把pivot元素交换到最终排序序列的正确位置上

	快速排序的一趟操作：
	patition(SqList &L, int low, int high) {
		L.r[0] = L.r[low];  // pivot元素放置在0位置
		pivotkey = L.r[low].key;

		// 最后low == high
		while (low < high )
		{
			//比pivot小的元素移到前面
			while (low<high && L.r[high].key >= pivotkey )
				--high;
			L.r[low] = L.r[high] 

			//比pivot大的元素移到数组后边
			while (low<high && L.r[low].key <= pivotkey)
				++low;
			L.r[high] = L.r[low]
		}
		L.r[low] = L.r[0]
		return low; // 返回划分索引位置
	}

T(n) = n + T(k-1) + T(n-k)，当序列有序时，快速排序退化为冒泡排序；改进：在指针high减1和low增1的同时进行“起泡”操作，若在一趟划分中没有“起泡”（交换）操作，则序列已有序；


3.选择排序
简单选择排序：
	void SelectSort( SqList &L )
	{
		// 选择第i小的记录，交换到位
		for (i=1; i<L.length; ++i )
		{
			// 从L.r[i...L.length]中选择最小的记录
			j = SelectMinKey(L, i ); 
			if (i!=j) L.r[i] <--> L.r[j]; //交换
		}
	}

选择排序在n个关键字中选出最小值时进行n-1次，能不能在接下来的选择第2小的关键字时，不进行n-2次操作呢？当然可以；

树形选择（胜者树）：
                          13
                       /      \
                   38            13
                 /    \         /    \
              38       65      13      27
             /  \     /  \    /  \    /   \
          49    38   65  97  76   13  27  49

	输出13后以MAXINT代替13，修改叶子到根的路径上的关键字，选出次小关键字
	（辅助空间多，需要与MAXINT的比较）


堆排序：
			13
                       /   \
		    38       27
                   /  \     /   \
                49     76  65    49
               /
             97
                 小顶堆（完全二叉树）
        输出13后，用97代替，从根结点向下调整堆结构；
        
        建堆时从最后一个非终端结点开始（floor(length/2)）
        void HeapSort( HeapType &H )
        {
        	// 建成大顶堆
        	for( i = H.length/2; i>0; --i )
        		HeapAdjust( H, i, H.length );

        	for( i = H.length; i>1; --i )
		{
			H.r[1] <--> H.r[i]; // 输出堆顶元素

			// 调整堆
        		HeapAdjust( H, 1, i-1);
		}
	}       

堆排序的运行时间主要耗费在建堆与调整新堆时的“筛选”操作上，深度为k的堆，筛选算法中的关键字比较至多为2(k-1)；



归并排序（2路归并）：
	void MSort( RcdType SR[], RcdType &TR1[], int s, int t ) {
		//将SR[s..t]归并排序为TR1[s..t]
		if (s==t ) TR1[s] = SR[s];
		else {
			m = (s+t) / 2;

			// 将SR[s..m]归并为有序的TR2[s..m]
			MSort (SR, TR2, s, m);

			// 将SR[m+1..t]归并为有序的TR2[m+1..t]
			MSort (SR, TR2, m+1, t);

			// 合并TR2[s..m]，TR2[m+1..t]到TR1[s..t]中
			Merge (TR2, TR1, s, m, t );
		}
	}

	2路归并算法不常用，多用多路归并；


4.计数排序，桶排序
若待排元素满足第个元素都是介于0到k之间的整数且k=O(n)，可以考虑使用计数排序;
	void countSort( A, B, k)
	{
		//对数组A进行排序放入数组B中，k为数组大小

		// 初始化计数数组C
		for i <- 0 to k
			do C[i] <- 0

		// 统计元素出现次数
		for  j <- 1 to length[A]
			do C[A[j]] <- C[A[j]] + 1 

		// 统计小于或等于i的元素个数
		for i <- 1 to k
			do C[i] <- C[i] + C[i-1]

		// 元素A[j]的最终排序位置在C[ A[j] ]	
		for j <- length[A] downto 1
			do B[ C[ A[j] ] ] <- A[j]
			   C[ A[j] ] <- C[ A[j] ] - 1
	}

桶排序：把区间[0,1)划分为n个相同大小的子区间（桶），将n个元素分布到桶中。输入数据均匀分布在[0, 1)中
	void bucketSort( A )
	{
		n <- length[A]
		
		// 把A中元素插入桶中
		for i <- 1 to n
			do inser A[i] into list B[ floor( n * A[i] ) ]

		for i <- 0 to n-1
			do sort list B[i] with insertion sort

		concatenate the lists B[0], B[1], ..., B[n-1] in order
	}

若A中元素分布为min < A[i] < max, 也可以令计算桶号的函数为floor( A[i] / (max - min + 1))，B数组元素个数为max-min+1






5.多关键字排序
基数排序：
	借助多关键字排序的思想对单逻辑关键字进行排序（如何对扑克牌排序？）

	( K0, K1, K2 ), 0<= Ki <=9 且为整数，K0为最主关键字，如3位整数中的百位
	最高位优先法（MSD）：
		先按K0排序，将序列分割成若干子序列，对子序列分别排序后合并
	
	最低位优先法（LSD）：
		对整个序列先按K2排序，再对K1进行排序（必须是稳定的排序算法），再按K0进行排序（稳定排序）

	使用LSD方法时，可以使用“分配”与“收集”思想实现排序

	
	使用链式结构：
		->278 -> 109 -> 063 -> 930 -> 589

		0: 930
		1: 
		....
		9: 109 589

		->930 ->063 -> 278 ->109 -> 589

	使用顺序结构：
		采用计数并“收集”的思想，类似于计数排序，需要n个记录与2*RADIX个计数单元的辅助空间
	



6.外部排序
	外部排序所需时间 = 内部排序（产生初始归并段）时间（m * tIS )  +
			   外部读写时间（ d * tIO ) +
			   内部归并所需时间 （s * u * tMG )

	如何有效减少外在信息读写次数呢？对m个初始归并段进行k路平衡归并时，归并的趟数为：s = floor( logk(m) )。因此增加k或减少m便能减少s，进而减少外存读写次数

多路平衡归并：
	降低归并树的深度

	使用多路归并使得归并树的深度降低，降低外存读写次数，但使得内部归并时间增加；
	对k路归并，得到u（k个归并段的总记录数）个记录的归并段需要进行(u-1)(k-1)次比较，因此内部归并过程中所用的比较次数为：
	floor(logk(m)) * (k-1) * (n-1)  

	使用败者树（双亲结点为败者，胜者往上参加另一场比赛），使得k个记录中选出最小关键字仅用floor(log2k)次比较
	floor(logk(m)) * floor(log2k) * (n-1)  = floor( log2m ) * (n-1)

	因此，总的内部归并时间保持不变；


置换-选择排序：
	减少初始归并段的数量，使用到败者树



最佳归并树：
	是一棵加上虚段后的哈夫曼树，结点为段的记录数

		2   3   6	
                  \ | /
                9  11  12  17 18 24
                  \ | /     \ | /
            30     32        59
               \    |      /
                   121

                加上0个虚段的3路最优归并树

       要是没有30这个段呢，直接在上边的树中去掉30并不是最优树（把6放到30的位置就比直接去掉30好），因此要附加长度为0的虚段，再构造哈夫曼树


       对k路归并而言，若(m-1) mod (k-1) = 0，则不需要加虚段（此时构造一棵哈夫曼树所有结点出度为0或k）；否则需要加 k - 1 - (m-1) mod (k-1) 个虚段（加上这个数量的虚段，(m' - 1) mod (k-1) = 0）； 
